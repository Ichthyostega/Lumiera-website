<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.4.5" />
<title></title>
<style type="text/css">
/* Debug borders */
p, li, dt, dd, div, pre, h1, h2, h3, h4, h5, h6 {
/*
  border: 1px solid red;
*/
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

tt {
  color: navy;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  font-family: sans-serif;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}

div.sectionbody {
  font-family: serif;
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}

pre {
  padding: 0;
  margin: 0;
}

span#author {
  color: #527bbd;
  font-family: sans-serif;
  font-weight: bold;
  font-size: 1.1em;
}
span#email {
}
span#revnumber, span#revdate, span#revremark {
  font-family: sans-serif;
}

div#footer {
  font-family: sans-serif;
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
div#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
div#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

div#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.tableblock, div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.5em;
  margin-bottom: 2.5em;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-family: sans-serif;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid silver;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid silver;
  background: #f4f4f4;
  padding: 0.5em;
}

div.quoteblock {
  padding-left: 2.0em;
  margin-right: 10%;
}
div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock {
  padding-left: 2.0em;
  margin-right: 10%;
}
div.verseblock > div.content {
  white-space: pre;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 2px solid silver;
}

div.exampleblock > div.content {
  border-left: 2px solid silver;
  padding: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

div.tableblock > table {
  border: 3px solid #527bbd;
}
thead {
  font-family: sans-serif;
  font-weight: bold;
}
tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

@media print {
  div#footer-badges { display: none; }
}

div#toctitle {
  color: #527bbd;
  font-family: sans-serif;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}
/* Workarounds for IE6's broken and incomplete CSS2. */

div.sidebar-content {
  background: #ffffee;
  border: 1px solid silver;
  padding: 0.5em;
}
div.sidebar-title, div.image-title {
  color: #527bbd;
  font-family: sans-serif;
  font-weight: bold;
  margin-top: 0.0em;
  margin-bottom: 0.5em;
}

div.listingblock div.content {
  border: 1px solid silver;
  background: #f4f4f4;
  padding: 0.5em;
}

div.quoteblock-attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock-content {
  white-space: pre;
}
div.verseblock-attribution {
  padding-top: 0.75em;
  text-align: left;
}

div.exampleblock-content {
  border-left: 2px solid silver;
  padding-left: 0.5em;
}

/* IE6 sets dynamically generated links as visited. */
div#toc a:visited { color: blue; }
</style>
</head>
<body>
<div id="header">
</div>
<div class="paragraph"><p><a id="renderengine-AllocationCluster"></a></p></div>
<h2 id="_allocationcluster">AllocationCluster</h2>
<div class="sectionbody">
<div class="paragraph"><p>Memory management facility for the low-level model (render nodes network). The model is organised into temporal segments, which are considered to be structurally constant and uniform. The objects within each segment are strongly interconnected, and thus each segment is being built in a single build process and is replaced or released as a whole. <tt>AllocationCluster</tt> implements memory management to support this usage pattern. He owns a number of object families of various types.</p></div>
<div class="imageblock">
<div class="content">
<img src="../draw/AllocationCluster.png" alt="../draw/AllocationCluster.png" />
</div>
</div>
<div class="ulist"><ul>
<li>
<p>
<a href="#renderengine-ProcNode">processing nodes</a>&#8201;&#8212;&#8201;probably with several subclasses (?)
</p>
</li>
<li>
<p>
<a href="#renderengine-WiringDescriptor">wiring descriptors</a>
</p>
</li>
<li>
<p>
the input/output descriptor arrays used by the latter
</p>
</li>
</ul></div>
<div class="paragraph"><p>To Each of those families we can expect an initially undetermined (but rather large) number of individual objects, which can be expected to be allocated within a short timespan and which are to be released cleanly on destruction of the AllocationCluster.</p></div>
<h3 id="_problem_of_calling_the_dtors">Problem of calling the dtors</h3><div style="clear:left"></div>
<div class="paragraph"><p>Even if the low-level memory manager(s) may use raw storage, we require that the allocated object&#8217;s destructors be called. This means keeping track at least of the number of objects allocated (without wasting too much memory for bookkeeping). Besides, as the objects are expected to be interconnected, it may be dangerous to destroy a given family of objects while another family of objects may rely on the former in its destructor. <em>If we happen do get into this situation,</em> we need to define a priority order on the types and assure the destruction sequence is respected.</p></div>
<div class="paragraph"><p>&#8594; see MemoryManagement</p></div>
<div class="paragraph"><p><a id="renderengine-Asset"></a></p></div>
</div>
<h2 id="_asset">Asset</h2>
<div class="sectionbody">
<div class="paragraph"><p>Asset management is a subsystem on its own. Assets are <em>things</em> that can be loaded into a session, like Media, Clips, Effects, Transitions. It is the <em>bookkeeping view</em>, while the EDL is the <em>manipulation and process view</em>. Some Assets can be <em>loaded</em> and a collection of Assets is saved with each Session. Besides, there is a collection of basic Assets always available by default.</p></div>
<div class="paragraph"><p>The Assets are important reference points holding the information needed to access external resources. For example, an Clip asset can reference a Media asset, which in turn holds the external filename from which to get the media stream. For Effects, the situation is similar. Assets thus serve two quite distinct purposes. One is to load, list, group search and browse them, and to provide an entry point to create new or get at existing MObjects in the EDL, while the other purpose is to provide attribute and property informations to the inner parts of the engine, while at the same time isolating and decoupling them from environmental details.</p></div>
<div class="paragraph"><p>We can distinguish several different Kinds of Assets, each one with specific properties. While all these Kinds of Assets implement the basic Asset interface, they in turn are the <em>key abstractions</em> of the asset management view. Mostly, their interfaces will be used directly, because they are quite different in behaviour. Thus it is common to see asset related operations being templated on the Asset Kind.</p></div>
<div class="paragraph"><p>&#8594; see also <a href="#renderengine-AssetCreation">Creating and registering Assets</a></p></div>
<div class="imageblock">
<div class="content">
<img src="../uml/fig130309.png" alt="../uml/fig130309.png" />
</div>
</div>
<h3 id="_media_asset">Media Asset</h3><div style="clear:left"></div>
<div class="paragraph"><p>Some piece of Media Data accessible at some external Location and able to be processed by Lumiera. A Media File on Harddisk can be considered as the most basic form of Media Asset, with some important derived flavours, like a Placeholder for a currently unavailable Source, or Media available in different Resolutions or Formats.</p></div>
<div class="ulist"><ul>
<li>
<p>
<em>outward interface operations</em> include querying properties, creating an Clip MObject, controlling processing policy (low res proxy placeholders, interlacing and other generic pre- and postprocessing)
</p>
</li>
<li>
<p>
<em>inward interface operations</em> include querying filename, codec, offset and any other informations necessary for creating a source render node, getting additional processing policy decisions (handling of interlacing, aspect ratio).
</p>
</li>
</ul></div>
<div class="paragraph"><p>&#8594; MediaAsset</p></div>
<h3 id="_processing_asset">Processing Asset</h3><div style="clear:left"></div>
<div class="paragraph"><p>Some software component able to work on media data in the Lumiera Render engine Framework. This includes all sorts of loadable effects, as well as some of the standard, internal facilities (Mask, Projector). Note that Processing Assets typically provide some attachment Point or means of communication with GUI facilities.</p></div>
<div class="ulist"><ul>
<li>
<p>
<em>outward interface operations</em> include getting name and description, investigating the media types the processor is able to handle, cause the underlying module to be acutally loaded&#8230;
</p>
</li>
<li>
<p>
<em>inward interface operations</em> include resolving the actual processing function.
</p>
</li>
</ul></div>
<div class="paragraph"><p>&#8594; ProcAsset</p></div>
<h3 id="_structural_asset">Structural Asset</h3><div style="clear:left"></div>
<div class="paragraph"><p>Some of the building blocks providing the framework for the objects placed into the current Session. Notable examples are <a href="#renderengine-Pipe">processing pipes</a> within the high-level-model, Viewer attachment points, Tracks, etc.</p></div>
<div class="ulist"><ul>
<li>
<p>
<em>outward interface operations</em> include&#8230;
</p>
</li>
<li>
<p>
<em>inward interface operations</em> include&#8230;
</p>
</li>
</ul></div>
<div class="paragraph"><p>&#8594; StructAsset <tt style="color: red;">to be defined</tt></p></div>
<h3 id="_meta_asset">Meta Asset</h3><div style="clear:left"></div>
<div class="paragraph"><p>Some additional, virtual facilities created in the course of the editing process. Examples are Automation data sets, Labels and reference points, Meta Clips (nested sub-EDLs)</p></div>
<div class="ulist"><ul>
<li>
<p>
<em>outward interface operations</em> include&#8230;
</p>
</li>
<li>
<p>
<em>inward interface operations</em> include&#8230;
</p>
</li>
</ul></div>
<div class="paragraph"><p>&#8594; MetaAsset <tt style="color: red;">to be defined</tt></p></div>
<h4 id="_still_to_be_worked_out">still to be worked out..</h4>
<div class="paragraph"><p>is how to implement the relationship between <a href="#renderengine-MObject">MObject</a>s and Assets. Do we use direct pointers, or do we prefer an ID + central registry approach? And how to handle the removal of an Asset.</p></div>
<div class="paragraph"><p>&#8594; see also <a href="#renderengine-ManagementAssetRelation">analysis of mem management</a></p></div>
<div class="paragraph"><p>&#8594; see also <a href="#renderengine-ObjectCreation">Creating Objects</a>, especially <a href="#renderengine-AssetCreation">Assets</a></p></div>
<div class="paragraph"><p><em>9/07: currently implementing it as follows: use a refcounting-ptr from Clip-MObject to asset::Media while maintaining a dependency network between Asset objects. We&#8217;ll see if this approach is viable</em></p></div>
<div class="paragraph"><p><a id="renderengine-AssetCreation"></a></p></div>
</div>
<h2 id="_assetcreation">AssetCreation</h2>
<div class="sectionbody">
<div class="paragraph"><p>Assets are created by a Factories returning smart pointers; the Asset creation is bound to specific use cases and <em>only available</em> for these specific situations. There is no generic Asset Factory.</p></div>
<div class="paragraph"><p>For every Asset we generate a <em>Ident tuple</em> and a long ID (hash) derived from this Ident tuple. The constructor of the abstract base class <tt>Asset</tt> takes care of this step and automatically registeres the new Asset object with the AssetManager. Typically, the factory methods for concrete Asset classes provide some shortcuts providing sensible default values for some of the Ident tuple data fields. They may take additional parameters&#8201;&#8212;&#8201;for example the factory method for creating <tt>asset::Media</tt> takes a filename (and may at some point in the future aply <em>magic</em> based on examination of the file  &#8594; LoadingMedia)</p></div>
<div class="paragraph"><p><a id="renderengine-AssetManager"></a></p></div>
</div>
<h2 id="_assetmanager">AssetManager</h2>
<div class="sectionbody">
<div class="paragraph"><p>The Asset Manager provides an Interface to some internal Database holding all Assets in the current Session and System state. It may be a real Database at some point (and for the moment it&#8217;s a Hashtable). Each <a href="#renderengine-Asset">Asset</a> is registered automatically with the Asset Manager; it can be queried either by it&#8217;s <em>identification tuple</em> or by it&#8217;s unique ID.</p></div>
<div class="paragraph"><p><a id="renderengine-AttachedPlacementProblem"></a></p></div>
</div>
<h2 id="_attachedplacementproblem">AttachedPlacementProblem</h2>
<div class="sectionbody">
<div class="paragraph"><p>Placing an MObject relatively to another object such that it should be handled as <em>attached</em> to the latter results in several design and implementation challenges. Actually, such an attachment creates a cluster of objects. The typical use case is that of an effect attached to a clip or processing pipe.</p></div>
<div class="ulist"><ul>
<li>
<p>
attachment is not a globally fixed relation between objects, rather, it typically exists only for some limited time span (e.g. the duration of the basic clip the effect is attached to)
</p>
</li>
<li>
<p>
the order of attachment is important and the attached placement may create a fork in the signal flow, so we need a way for specifying reproducibly how the resulting wiring should be
</p>
</li>
<li>
<p>
when building, we access the information in reversed direction: we have the target object and need to query for all attachments
</p>
</li>
</ul></div>
<div class="paragraph"><p>The first step towards an solution is to isolate the problem; obviously we don&#8217;t need to store the objects differently, we just need <em>information about attached objects</em> for some quite isolated tasks (namely for creating a GUI representation and for combining attached objects into a <a href="#renderengine-Pipe">Pipe</a> when building). Resorting to a query (function call) interface should turn the rest of the problem into an implementation detail. Thus:</p></div>
<div class="ulist"><ul>
<li>
<p>
for an <em>attachment head</em> (= <tt>Placement&lt;MObject&gt;</tt> to which other objects have been attached) get the ordered list of attachments
</p>
</li>
<li>
<p>
for an <em>attached placement</em> (member of the cluster) get the placement of the corresponding attachment head
</p>
</li>
<li>
<p>
retrieve and break the attachment when <em>deleting.</em>
</p>
</li>
</ul></div>
<h3 id="_implementation_notes">Implementation notes</h3><div style="clear:left"></div>
<div class="paragraph"><p>Attachment is managed within the participating placements, mostly by special <a href="#renderengine-LocatingPin">locating pins</a>. Attachment doesn&#8217;t necessarily nail down an attached object to a specific position, rather the behaviour depends on the type of the object and the locating pins actually involved, especially on their order and priority. For example, if an <tt>Placement&lt;Effect&gt;</tt> doesn&#8217;t contain any locating pin defining a temporal position, then the attachment will result in the placement inheriting the temporal placement of the <em>attachment head</em> (i.e. the clip this effect has been attached to). But, if on the contrary the effect in question <em>does</em> have an additional locating pin, for example relative to another object or even to a fixed time position, this one will <em>win</em> and determine the start position of the effect&#8201;&#8212;&#8201;it may even move the effect out of the time interval covered by the clip, in which case the attachment has no effect on the clip&#8217;s processing pipe.</p></div>
<div class="paragraph"><p>The attachment relation is hierarchical and has a clearly defined <em>active</em> and <em>passive</em> side: The attachment head is the parent node in a tree, but plays the role of the passive partner, to which the child nodes attach. But note, this does not mean we are limited to a single attachment head. Actually, each placement has a list of locating pins and thus can attach to several other placements. For example, a transition attaches to at least two local pipes (clips). <tt style="color: red;">TODO: unresolved design problem; seems to contradict the PlacementScope</tt></p></div>
<h4 id="_relation_to_memory_management">Relation to memory management</h4>
<div class="paragraph"><p>Attachment on itself does <em>not</em> keep an object alive. Rather, it&#8217;s implemented by an opaque ID entry ( &#8594; PlacementRef), which can be resolved by the PlacementIndex. The existence of attachments should be taken into account when deleting an object, preferably removing any dangling attachments to prevent an exception to be thrown later on. On the other hand, contrary to the elements of the HighLevelModel, processing nodes in the render engine never depend on placements&#8201;&#8212;&#8201;they always refer directly to the MObject instance or even the underlying asset. In the case of MObject instances, the pointer from within the engine will <em>share ownership</em> with the placement (remember: both are derived from <tt>boost::shared_ptr</tt>).</p></div>
<div class="paragraph"><p><a id="renderengine-Automation"></a></p></div>
</div>
<h2 id="_automation">Automation</h2>
<div class="sectionbody">
<div class="paragraph"><p>Automation is treated as a function over time. It is always tied to a specific Parameter (which can thus be variable over the course of the timeline). All details <em>how</em> this function is defined are completely abstracted away. The Parameter uses a ParamProvider to get the value for a given Time (point). Typically, this will use linear or bezier interpolation over a set of keyframes internally. Parameters can be configured to have different value ranges and distribution types (on-off, stepped, continuous, bounded)</p></div>
<div class="imageblock">
<div class="content">
<img src="../uml/fig129669.png" alt="../uml/fig129669.png" />
</div>
</div>
<div class="paragraph"><p><a id="renderengine-AutomationData"></a></p></div>
</div>
<h2 id="_automationdata">AutomationData</h2>
<div class="sectionbody">
<div class="paragraph"><p>While generally automation is treated as a function over time, defining and providing such a function requires some <em>Automation Data.</em> The actual layout and meaning of this data is deemed an implementation detail of the <a href="#renderengine-ParamProvider">parameter provider</a> used, but nevertheless an automation data set has object characteristics within the <a href="#renderengine-EDL">EDL (high-level-model)</a>, allowing it to be attached, moved and <a href="#renderengine-Placement">placed</a> by the user.</p></div>
<div class="paragraph"><p><a id="renderengine-BasicBuildingOperations"></a></p></div>
</div>
<h2 id="_basicbuildingoperations">BasicBuildingOperations</h2>
<div class="sectionbody">
<div class="paragraph"><p>Starting out from the concepts of Objects, Placement to Tracks, render Pipes and connection properties ( &#8594; see <a href="#renderengine-TrackPipeEDL">here</a>) within the EDL, we can identify the elementary operations occuring within the Builder. Overall, the Builder is organized as application of <em>visiting tools</em> to a collection of objects, so finally we have to consider some object kind appearing in the working function of the given builder tool, which holds at this moment some <em>context</em>. The job now is to organize this context such as to create a predictable build process from this <em>event driven</em> approach.
 &#8594;see also: BuilderPrimitives for the elementary situations used to cary out the building operations</p></div>
<h3 id="_builder_working_situations">Builder working Situations</h3><div style="clear:left"></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
any <strong>Clip</strong> (which at this point has been reduced already to a part of a simple elementary media stream  &#8594; see <a href="#renderengine-Fixture">Fixture</a>)
</p>
<div class="olist loweralpha"><ol class="loweralpha">
<li>
<p>
yields a source reading node
</p>
</li>
<li>
<p>
which needs to be augmented by the underlying media&#8217;s <a href="#renderengine-ProcPatt">processing pattern</a>
</p>
<div class="ulist"><ul>
<li>
<p>
thus inserting codec(s) and source transformations
</p>
</li>
<li>
<p>
effectively this is an application of effects
</p>
</li>
</ul></div>
</li>
<li>
<p>
at this point we have to process (and maybe generate on-the-fly) the <a href="#renderengine-ClipSourcePort">source port of this clip</a>
</p>
<div class="ulist"><ul>
<li>
<p>
the output of the source reading and preprocessing defined thus far is delivered as input to this port, which is done by a WiringRequest (see below)
</p>
</li>
<li>
<p>
as every port, it is the entry point to a <a href="#renderengine-Pipe">processing pipe</a>, thus the source port has a processing pattern, typically inserting the camera (transformation effect) at this point
</p>
</li>
</ul></div>
</li>
<li>
<p>
followed by the application of effects
</p>
<div class="ulist"><ul>
<li>
<p>
separately for every effect chain rooted (placed) directly onto the clip
</p>
</li>
<li>
<p>
and regarding the chaining order
</p>
</li>
</ul></div>
</li>
<li>
<p>
next we have to assess the <a href="#renderengine-Pipe">pipes</a> to which the clip has been placed
</p>
</li>
<li>
<p>
producing a <a href="#renderengine-WiringRequest">wiring request</a> for every pair <tt>(chainEndpoint, pipe)</tt>
</p>
<div class="imageblock">
<div class="content">
<img src="../draw/Proc.builder1.png" alt="../draw/Proc.builder1.png" />
</div>
</div>
</li>
</ol></div>
</li>
<li>
<p>
attaching an <strong>Effect</strong> is actually always an <em>insertion operation</em> which is done by <em>prepending</em> to the previously built nodes. Effects may be placed as attached to clips and pipes, which causes them to be included in the processing chain at the given location. Effects may as well be placed at an absolute time, which means they are to be applied to every clip that happens to be at this time&#8201;&#8212;&#8201;but this usecase will be reolved when creating the Fixture, causing the effect to be attached to the clips in question. The same holds true for Effects put on tracks.
</p>
</li>
<li>
<p>
treating an <strong>wiring request</strong> means
</p>
<div class="olist loweralpha"><ol class="loweralpha">
<li>
<p>
detecting possible and impossible connections
</p>
</li>
<li>
<p>
deriving additional possible <em>placement dimensions</em> generated by executing such an connection (e.g. connecting a mono source to a spatial sound system bus creates panning possibilities)
</p>
<div class="ulist"><ul>
<li>
<p>
deriving parameter sources for this additional degrees of freedom
</p>
</li>
<li>
<p>
fire off insertion of the necessary effects to satisfy this connection request and implement the additional <em>placement dimensions</em> (pan, layer order, overlay mode, MIDI channel selection&#8230;)
</p>
</li>
</ul></div>
</li>
</ol></div>
</li>
<li>
<p>
processing the effects and further placements <strong>attached to a Pipe</strong> is handled identical to the processing done with all attachments to individual clips.
</p>
</li>
<li>
<p>
<strong>Transitions</strong> are to be handled differently according to their placement ( &#8594; more on <a href="#renderengine-TransitionsHandling">Transitions</a>)
</p>
<div class="ulist"><ul>
<li>
<p>
when placed normally to two (or N) clips, they are inserted at the exit node of the clip&#8217;s complete effect chain.
</p>
</li>
<li>
<p>
otherwise, when placed to the source port(s) or when placed to some other pipes they are inserted at the exit side of those pipe&#8217;s effect chains. (Note: this puts additional requirements on the transition processor, so not every transition can be placed this way)
After consuming all input objects and satisfying all wiring requests, the result is a set of <a href="#renderengine-ExitNode">exit nodes</a> ready for pulling data. We call the network reachable from such an exit node a <a href="#renderengine-Processor">Processor</a>, together all processors of all segments and output data types comprise the render engine.
</p>
</li>
</ul></div>
</li>
</ol></div>
<h4 id="_dependencies">dependencies</h4>
<div class="paragraph"><p>Pipes need to be there first, as everything else will be plugged (placed) to a pipe at some point. The same holds true for tracks. But, on the other hand, both are optional. We can have EDLs with MObjects without configuring pipes (but won&#8217;t be able to build any render processor of course). And we could have an EDL without any track, if we place every MObject within this EDL directly to some pipe.</p></div>
<div class="paragraph"><p>Effects can be attached only to already existing pipelines, starting out at some pipes entry port or the source port of some clip. Besides that, all further parts can be built in any order and independent of each other. This is made possible by using <a href="#renderengine-WiringRequest">wiring requests</a>, which can be resolved later on. So, as long as we start out with the tracks (to resolve any pipe they are placed to), and further, if we manage to get any effect placed to some clip-MO <em>after</em> setting up and treating the clip, we are fine and can do the building quasi event driven.</p></div>
<h4 id="_building_and_resolving">building and resolving</h4>
<div class="paragraph"><p>Building the network for the individual objects thus creates a queue of wiring requests. Some of them may be immediately resolvable, but detecting this correctly can be nontrivial, and so it seems better to group all wiring requests based on the pipe and treat them groupwise. Because&#8201;&#8212;&#8201;in the most general case&#8201;&#8212;&#8201;connecting includes the use of transforming and joining nodes, which can create additional wiring requests (e.g. for automation parameter data connections). Finally, if the network is complete, we could perform <a href="#renderengine-RenderNetworkOptimisation">optimisations</a></p></div>
<div class="paragraph"><p><a id="renderengine-BindingMO"></a></p></div>
</div>
<h2 id="_bindingmo">BindingMO</h2>
<div class="sectionbody">
<div class="paragraph"><p>Sometimes, two entities within the <a href="#renderengine-Session">Session</a> are deliberately associated, and this association has to carry some specific mappings between properties or facilities within the entities to be linked together. When this connection isn&#8217;t just the <a href="#renderengine-Placement">Placement</a> of an object, and isn&#8217;t just a logical or structural relationship either&#8201;&#8212;&#8201;then we create an explicit Binding object to be stored into the session.</p></div>
<div class="ulist"><ul>
<li>
<p>
When connecting a <a href="#renderengine-EDL">Sequence</a> to a certain <a href="#renderengine-Timeline">Timeline</a>, we also establish a mapping between the possible media stream channels produced by the sequence and the real output slots found within the timeline.
</p>
</li>
<li>
<p>
similarly, using a sequence within a <a href="#renderengine-VirtualClip">meta-clip</a> requires to remember such a mapping.
</p>
</li>
<li>
<p>
another example is the root <a href="#renderengine-PlacementScope">scope</a>, which (conceptually) is a link between the definition part of the Session and the graph of MObjects, which are the session&#8217;s contents.
</p>
</li>
</ul></div>
<div class="paragraph"><p>On the implementation side, we use a special kind of MObject, acting as an anchor and providing an unique identity. Like any MObject, actually a placement establishes the connection and the scope, and typically constitutes a nested scope (e.g. the scope of all objects <em>within</em> the sequence to be bound into a timeline)</p></div>
<div class="paragraph"><p><a id="renderengine-BuildProcess"></a></p></div>
</div>
<h2 id="_buildprocess">BuildProcess</h2>
<div class="sectionbody">
<div class="paragraph"><p>All decisions on <em>how</em> the RenderProcess has to be carried out are concentrated in this rather complicated Builder Subsystem. The benefit of this approach is, besides decoupling of subsystems, to keep the actual performance-intensive video processing code as simple and transparent as possible. The price, in terms of increased complexity&#8201;&#8212;&#8201;to pay in the Builder&#8201;&#8212;&#8201;can be handled by making the Build Process generic to a large degree. Using a Design By Contract approach we can decompose the various decisions into small decision modules without having to trace the actual workings of the Build Process as a whole.</p></div>
<div class="imageblock">
<div class="content">
<img src="../uml/fig129413.png" alt="../uml/fig129413.png" />
</div>
</div>
<div class="paragraph"><p>The building itself will be broken down into several small tool application steps. Each of these steps has to be mapped to the MObjects found on the <a href="#renderengine-Timeline">Timeline</a>. Remember: the idea is that the so called <tt><a href="#renderengine-Fixture">Fixture</a></tt> contains only <a href="#renderengine-ExplicitPlacement">ExplicitPlacement</a>s which in turn link to MObjects like Clips, Effects and <a href="#renderengine-Automation">Automation</a>. So it is sufficient to traverse this list and map the build tools to the elements. Each of these build tools has its own state, which serves to build up the resulting Render Engine. So far I see two steps to be necessary:</p></div>
<div class="ulist"><ul>
<li>
<p>
find the <tt>Segments</tt>, i.e. the locations where the overall configuration changes
</p>
</li>
<li>
<p>
for each segment: generate a ProcNode for each found MObject and wire them accordingly
</p>
</li>
</ul></div>
<div class="paragraph"><p>Note, <em>we still have to work out how exactly building, rendering and playback work</em> together with the backend-design. The build process as such doesn&#8217;t overly depend on these decisions. It is easy to reconfigure this process. For example, it would be possible as well to build for each frame separately (as Cinelerra2 does), or to build one segment covering the whole timeline (and handle everything via <a href="#renderengine-Automation">Automation</a></p></div>
<div class="paragraph"><p>&#8594; see also: <a href="#renderengine-Builder">Builder Overview</a>
&#8594; see also: BasicBuildingOperations
&#8594; see also: BuilderStructures
&#8594; see also: BuilderMechanics
&#8594; see also: PlanningBuildFixture
&#8594; see also: PlanningSegementationTool
&#8594; see also: PlanningNodeCreatorTool</p></div>
<div class="imageblock">
<div class="content">
<img src="../uml/fig128517.png" alt="../uml/fig128517.png" />
</div>
</div>
<div class="paragraph"><p><a id="renderengine-BuildRenderNode"></a></p></div>
</div>
<h2 id="_buildrendernode">BuildRenderNode</h2>
<div class="sectionbody">
<div class="paragraph"><p>Actually setting up and wiring a <a href="#renderengine-ProcNode">processing node</a> involves several issues and is carried out at the lowest level of the build process.
It is closely related to  &#8594; <a href="#renderengine-NodeOperationProtocol">the way nodes are operated</a> and the  &#8594; <a href="#renderengine-RenderMechanics">mechanics of the render process</a></p></div>
<h3 id="_object_creation">object creation</h3><div style="clear:left"></div>
<div class="paragraph"><p>The Nodes are small polymorphic objects, carrying configuration data, but no state. They are <a href="#renderengine-ManagementRenderNodes">specially allocated</a>, and the object creation is accessible by means of the NodeFactory solely. They <em>must not be deallocated manually.</em> The decision of what concrete node type to create depends on the actual build situation and is worked out by the combination of <a href="#renderengine-BuilderMould">mould</a> and <a href="#renderengine-ProcPatt">processing pattern</a> at the current OperationPoint, issuing a call to one of NodeFactory&#8217;s <tt>operator()</tt></p></div>
<h3 id="_node_plugin_and_processing_function">node, plugin and processing function</h3><div style="clear:left"></div>
<div class="paragraph"><p>Its a good idea to distinguish clearly between those concepts. A plugin is a piece of (possibly external) code we use to carry out operations. We have to <em>discover its properties and capabilities.</em> We don&#8217;t have to discover anything regarding nodes, because we (Lumiera builder and renderengine) are creating, configuring and wiring them to fit the specific purpose. Both are to be distinguished from processing functions, which do the actual calculations on the media data. Every node typically encompasses at least one processing function, which may be an internal function in the node object, a library function from Lumiera or GAVL, or external code loaded from a plugin.</p></div>
<h3 id="_node_interfaces">node interfaces</h3><div style="clear:left"></div>
<div class="paragraph"><p>As a consequence of this distinctions, in conjunction with a processing node, we have to deal with three different interfaces</p></div>
<div class="ulist"><ul>
<li>
<p>
the <em>build interface</em> is used by the builder to set up and wire the nodes. It can be full blown C++ (including templates)
</p>
</li>
<li>
<p>
the <em>operation interface</em> is used to run the calculations, which happens in cooperation of Proc-Layer and Backend. So a function-style interface is preferable.
</p>
</li>
<li>
<p>
the <em>inward interface</em> is accessed by the processing function in the course of the calculations to get at the necessary context, including in/out buffers and param values.
</p>
</li>
</ul></div>
<h3 id="_wiring_data_connections">wiring data connections</h3><div style="clear:left"></div>
<div class="paragraph"><p>A node <em>knows its predecessors, but not its successors.</em> When being <em>pulled</em> in operation, it can expect to get a frame provider for accessing the in/out buffer locations (some processing functions may be <em>in-place capable</em>, but that&#8217;s only a special case of the former). At this point, the <strong>pull principle</strong> comes into play: the node may request input frames from the frame provider, passing its predecessors as a <strong>continuation</strong>.</p></div>
<div class="paragraph"><p>With regard to the build process, the wiring of data connections translates into providing the node with its predecessors and preconfiguring the possible continuations. While in the common case, a node has just one input/output and pulls from its predecessor a frame for the same timeline position, the general case can be more contrived. A node may process N buffers in parallel and may require several different time positions for it&#8217;s input, even at a differing framerate. So the actual source specification is (predNode,time,frameType). The objective of the wiring done in the build process is to factor out the parts known in advance, while in the render process only the variable part need to be filled in. Or to put it differently: wiring builds a higher order function (time)&#8594;(continuation), where continuation can be invoked to get the desired input frame.</p></div>
<h3 id="_wiring_control_conections">wiring control conections</h3><div style="clear:left"></div>
<div class="paragraph"><p>In many cases, the parameter values provided by these connections aren&#8217;t frame based data, rather, the processing function needs a call interface to get the current value (value for a given time), which is provided by the parameter object. Here, the wiring needs to link to the suitable parameter instance, which is located within the high-level model (!). As an additional complication, calculating the actual parameter value may require a context data frame (typically for caching purposes to speed up the interpolation). While these parameter context data frames are completely opaque for the render node, they have to be passed in and out similar to the state needed by the node itself, and the wiring has to prepare for accessing these frames too.</p></div>
<div class="paragraph"><p><a id="renderengine-Builder"></a></p></div>
</div>
<h2 id="_builder">Builder</h2>
<div class="sectionbody">
<div class="paragraph"><p>The Builder takes some MObject/<a href="#Placement">Placement</a> information (called Timeline) and generates out of this a Render Engine configuration able to render this Objects. It does all decisions and retrieves the current configuration of all objects and plugins, so the Render Engine can just process them stright forward.</p></div>
<div class="paragraph"><p>The Builder is the central part of the <a href="http://en.wikipedia.org/wiki/Builder_pattern">Builder Pattern</a></p></div>
<div class="paragraph"><p>As the builder has to create a render node network implementing most of the features and wiring possible with the various MObject kinds and placement types, it is a rather complicated piece of software. In order to keep it manageable, it is broken down into several specialized sub components:</p></div>
<div class="ulist"><ul>
<li>
<p>
clients access builder functionality via the BuilderFacade
</p>
</li>
<li>
<p>
the <a href="#renderengine-Controller">Proc-Layer-Controller</a> initiates the BuildProcess and does the overall coordination of scheduling edit operations, rebuilding the fixture and triggering the Builder
</p>
</li>
<li>
<p>
to carry out the building, we use several primary tools (SegmentationTool, NodeCreatorTool,&#8230;),  together with a BuilderToolKit to be supplied by the <a href="#renderengine-BuilderToolFactory">tool factory</a>
</p>
</li>
<li>
<p>
<em>operating the Builder</em> can be viewed at from two different angles, either emphasizing the <a href="#renderengine-BasicBuildingOperations">basic building operations</a> employed to assemble the render node network, or focussing rather at the <a href="#renderengine-BuilderMechanics">mechanics</a> of cooperating parts while processing.
</p>
</li>
<li>
<p>
besides, we can identify a small set of elementary situations we call <a href="#renderengine-BuilderPrimitives">builder primitives</a>, to be covered by the mentioned BuilderToolKit; by virtue of <a href="#renderengine-ProcPatt">processing patterns</a> they form an <a href="#renderengine-BuilderRulesInterface">interface to the rule based configuration</a>.
</p>
</li>
<li>
<p>
the actual building (i.e. the application of tools to the timeline) is done by the <a href="#renderengine-BuilderAssembler">Assembler</a>, which is basically a collection of functions (but has a small amount of global configuration state)
</p>
</li>
<li>
<p>
any non-trivial wiring of render nodes, tracks, pipes and <a href="#renderengine-Automation">automation</a> is done by the services of the <a href="#renderengine-ConManager">connection manager</a>
</p>
</li>
</ul></div>
<div class="paragraph"><p><a id="renderengine-BuilderMechanics"></a></p></div>
</div>
<h2 id="_buildermechanics">BuilderMechanics</h2>
<div class="sectionbody">
<div class="paragraph"><p>The cooperation of several components creates a context of operation for the primary builder working tool, the <a href="#renderengine-PlanningNodeCreatorTool">node creator</a></p></div>
<div class="ulist"><ul>
<li>
<p>
the BuilderToolFactory acts as the <em>builder for the builder tools</em>, i.e. we can assume to be able to retrive all needed primary tools and elementary tools from this factory, completely configured and ready to use.
</p>
</li>
<li>
<p>
the <a href="#renderengine-BuilderAssembler">Assembler</a> has the ability to consume objects from the high level model and feed them to the node creator (which translates into a dispatch of individual operations suited to the objects to be treated). This involves some sort of scheduling or ordering of the operaions, which is the only means to direct the overall process such as to create a sensible and usable result. <em>This is an fundamental design decision:</em> the actual working tools have no hard wired knowledge of the <em>right process</em>, which makes the whole Builder highly configurable (<em>open</em>).
</p>
</li>
<li>
<p>
the <a href="#renderengine-ConManager">connection manager</a> on the contrary is a passive service provider. Fed with <a href="#renderengine-WiringRequest">wiring requests</a>, he can determine if a desired connection is possible, and what steps to take to implement it; the latter recursively creates further building requests to satisfy by the assembler, and possibly new wiring requests.
</p>
</li>
</ul></div>
<h3 id="_pattern_of_operation">pattern of operation</h3><div style="clear:left"></div>
<div class="paragraph"><p>The working pattern of this builder mechanics can be described as triggering, enqueuing, priorizing, recursing and exhausting. Without the priorizing part, it would be a depth-first call graph without any context state, forcing us to have all cross reference information available at every node or element to be treated. We prefer to avoid this overhead by ordering the operations into several phases and within these phases into correlated entities with the help of a <strong>weighting function</strong> and scheduling with a <strong>priority queue</strong></p></div>
<h3 id="_call_chain">call chain</h3><div style="clear:left"></div>
<div class="paragraph"><p>After preparing the tools with the context state of this build process, the assembler drives the visitation process in the right order. The functions embedded within the visitor (NodeCreatorTool) for treating specific kinds of objects in turn use the toolkit (=the fully configured tool factory) to get the mould(s) for the individual steps they need to carry out. This involves preparing the mould (with the high-level object currently in-the-works, a suitable processing pattern and additional references), followed by operating the mould. The latter <em>plays</em> the processing pattern in the context of the mould, which, especially with the help of the operation point, carries out the actual building and/or connecting step. While doing so, the node factory will be invoked, which in turn invokes the wiring factory and thus pre-determines the node&#8217;s prospective mode of operation when later called for rendering.</p></div>
<div class="paragraph"><p><a id="renderengine-BuilderMould"></a></p></div>
</div>
<h2 id="_buildermould">BuilderMould</h2>
<div class="sectionbody">
<div class="paragraph"><p>The <a href="#renderengine-Builder">Builder</a> uses different kinds of tools for creating a network of render nodes from a given high-level model. When breaking down this (necessarily complex) process into small manageable chunks, we arrive at <a href="#renderengine-BuilderPrimitives">elementary building situations</a>. For each of these there is a specialized tool. We denote these tools as <em>moulds</em> because they are a rather passive holder for the objects to be attached and wired up. They are shaped according to the basic form the connections have to follow for each of these basic situations:</p></div>
<div class="ulist"><ul>
<li>
<p>
attaching an effect to a pipe
</p>
</li>
<li>
<p>
combining pipes via a transition
</p>
</li>
<li>
<p>
starting out a pipe from a source reader
</p>
</li>
<li>
<p>
general connections from the exit node of a pipe to the port of another pipe
</p>
</li>
</ul></div>
<div class="paragraph"><p>In all those cases, the active part is provided by <a href="#renderengine-ProcPatt">processing patterns</a>&#8201;&#8212;&#8201;sort of micro programs executed within the context of a given mould: the processing pattern defines the steps to take (in the standard/basic case this is just <em>attach</em>), while the mould holds and provides the location where these steps will operate. Actually, this location is represented as a OperationPoint, provided by the mould and abstracting the details of making multi-channel connections.</p></div>
<div class="paragraph"><p><a id="renderengine-BuilderPrimitives"></a></p></div>
</div>
<h2 id="_builderprimitives">BuilderPrimitives</h2>
<div class="sectionbody">
<div class="paragraph"><p>While assembling and building up the render engines node network, a small number of primitive building situations is encountered repeatedly. The BuilderToolKit provides a <tt><a href="#renderengine-BuilderMould">mould</a></tt> for each of these situations, typically involving parametrisation and the application of a <a href="#renderengine-ProcPatt">processing pattern</a>.</p></div>
<div class="paragraph"><p>The <strong>Lifecycle</strong> of such a mould starts out by arming it with the object references involved into the next building step. After conducting this building step, the resulting render nodes can be found&#8201;&#8212;&#8201;depending on the situation&#8201;&#8212;&#8201;attached either to the same mould, or to another kind of mould, but in any case ready to be included in the next building step. Thus, <em>effectively</em> the moulds are <em>used to handle the nodes being built</em>, due to the fact that the low-level model (nodes to be built) and the high-level model (objects directing what is to be built) are <em>never connected directly</em>.</p></div>
<h3 id="_list_of_elementary_building_situations">List of elementary building situations</h3><div style="clear:left"></div>
<h4 id="_inserting_an_effect_or_plugin">inserting an Effect or Plugin</h4>
<div class="imageblock">
<div class="content">
<img src="../draw/builder-primitives1.png" alt="../draw/builder-primitives1.png" />
</div>
</div>
<div class="paragraph"><p>The <tt>PipeMould</tt> is used to chain up the effects attached to a clip (=local pipe) or global pipe (=bus)</p></div>
<div class="ulist"><ul>
<li>
<p>
participating: a Pipe and an Effect
</p>
</li>
<li>
<p>
point of reference: current exit node of the pipe
</p>
</li>
<li>
<p>
result: Effect appended at the pipe&#8217;s exit node
</p>
</li>
<li>
<p>
returns: PipeMould holding onto the new exit node
</p>
</li>
</ul></div>
<h4 id="_attaching_a_transition">attaching a transition</h4>
<div class="imageblock">
<div class="content">
<img src="../draw/builder-primitives2.png" alt="../draw/builder-primitives2.png" />
</div>
</div>
<div class="paragraph"><p>After having completed N pipe&#8217;s node chains, a <tt>CombiningMould</tt> can be used to join them into a <a href="#renderengine-TransitionsHandling">transition</a></p></div>
<div class="ulist"><ul>
<li>
<p>
participating: N pipe&#8217;s exit nodes, transition
</p>
</li>
<li>
<p>
point of reference: N exit nodes corresponding to (completed) pipes
</p>
</li>
<li>
<p>
result: transition has been attached with the pipe&#8217;s exit nodes, new wiring requests created attached to the transition&#8217;s exit node(s)
</p>
</li>
<li>
<p>
returns: WiringMould, connected with the created wiring request
</p>
</li>
</ul></div>
<div class="paragraph"><p>Using this mould implicitly <em>closes</em> the involved pipes, which means that we give up any reference to the exit node and can&#8217;t build any further effect attached to this pipes. Generally speaking, <em>exit node</em> isn&#8217;t a special kind of node, rather it&#8217;s a node we are currently holding on. Similarly, there is nothing directly correlated to a pipe within the render nodes network after we are done with building the part of the network corresponding to the pipe; the latter serves rather as a blueprint for building, but isn&#8217;t an entity in the resulting low-level model.
Actually, there is <tt style="color: red;">planned</tt> a more general (and complicated) kind of transition, which can be inserted into N data connections without joining them together into one single output, as the standard transitions do. The CombiningMould can handle this case too by just returning N wiring moulds as a result.</p></div>
<h4 id="_building_a_source_connection">building a source connection</h4>
<div class="imageblock">
<div class="content">
<img src="../draw/builder-primitives3.png" alt="../draw/builder-primitives3.png" />
</div>
</div>
<div class="paragraph"><p>The <tt>SourceChainMould</tt> is used as a starting point for any further building, as it results in a local pipe (=clip) rooted at the clip source port. This reflects the fact that the source readers (=media access points) are the <em>leaf nodes</em> in the node graph we are about to build.</p></div>
<div class="ulist"><ul>
<li>
<p>
participating: source port of a clip, media access point, <a href="#renderengine-ProcPatt">processing pattern</a>
</p>
</li>
<li>
<p>
point of reference: <em>none</em>
</p>
</li>
<li>
<p>
result: processing pattern has been <em>executed</em>, resulting in a chain of nodes from the source reader to the clip source port
</p>
</li>
<li>
<p>
returns: PipeMould holding onto the new exit node (of a yet-empty pipe)
</p>
</li>
</ul></div>
<h4 id="_wiring_a_general_connection">wiring a general connection</h4>
<div class="paragraph"><p>Any wiring (outside the chain of effects within a pipe) is always done from exit nodes to the port of another pipe, requiring an <a href="#renderengine-WiringRequest">wiring request</a> already checked and deemed resolvable. Within the <tt>WiringMould</tt> the actual wiring is conducted, possibly adding a summation node (called <em>overlayer</em> in case of video) and typically a fader element (the specific setup to be used is subject to configuration by processing patterns)</p></div>
<div class="ulist"><ul>
<li>
<p>
participating: already verified connection request, providing a Pipe and an exit node; a processing pattern and a Placement
</p>
</li>
<li>
<p>
points of reference: exit node and (optionally) starting point of a pipe&#8217;s chain (in case there are already other connections)
</p>
</li>
<li>
<p>
result: summation node prepended to the port of the pipe, processing pattern has been <em>executed</em> for building the connection from the exit node to the pipe&#8217;s port, ParamProvider has been setup in <a href="#renderengine-PlacementDerivedDimension">accordance</a> to the Placement.
</p>
</li>
<li>
<p>
returns: PipeMould holding onto the destination pipe&#8217;s exit node, WiringMould holding onto the port side of the same pipe, i.e. the destination where further connections will insert summation nodes. <tt style="color: red;">TODO how to handle the <em>empty</em>-case?</tt>
</p>
</li>
</ul></div>
<div class="imageblock">
<div class="content">
<img src="../draw/builder-primitives4.png" alt="../draw/builder-primitives4.png" />
</div>
</div>
<div class="paragraph"><p><a id="renderengine-BuilderStructures"></a></p></div>
</div>
<h2 id="_builderstructures">BuilderStructures</h2>
<div class="sectionbody">
<div class="ulist"><ul>
<li>
<p>
the MObjects implement <em>Buildable</em>
</p>
</li>
<li>
<p>
each Buildable can <em>receive</em> a Tool object and apply it
</p>
</li>
<li>
<p>
the different Tool objects are iterated/mapped onto the list of MObjects in the <a href="#renderengine-Timeline">Timeline</a>
</p>
</li>
<li>
<p>
<em>Rationale</em>
</p>
<div class="ulist"><ul>
<li>
<p>
the MObject class hierarchy is rather fixed (it is unlikely the we will be adding much new MObject subclasses)
</p>
</li>
<li>
<p>
so this design makes it easy to add new Tool subclasses, and within each Tool subclass, all operations on the different MObject classes are grouped together, so it is easy to see what is going on.
</p>
</li>
<li>
<p>
a given Tool instance can carry state while being iterated, so we don&#8217;t need any global (or object-global) variables to hold the result of the build process
</p>
</li>
</ul></div>
</li>
</ul></div>
<div class="paragraph"><p>This programming technique is often referred to as <a href="#renderengine-VisitorUse"><tt>double dispatch</tt> or <tt>visitor</tt></a>. We use a specialized library implementation of this pattern&#8201;&#8212;&#8201;heavily inspired by the <a href="http://loki-lib.sourceforge.net">Loki library</a>. We use this approach not only for the builder, but also for carrying out operations on the objects in the EDL in a typesafe manner.
It is the low level foundation of the actual <a href="#renderengine-BasicBuildingOperations">building operations</a> necessary to create render nodes starting from the given high level model.</p></div>
<div class="imageblock">
<div class="content">
<img src="../uml/fig129285.png" alt="../uml/fig129285.png" />
</div>
</div>
<h3 id="_colaborations">Colaborations</h3><div style="clear:left"></div>
<div class="paragraph"><p>While building, the application of such a visiting tool (especially the <a href="#renderengine-PlanningNodeCreatorTool">NodeCreatorTool</a>) is embedded into an execution context formed by the BuilderToolFactory providing our BuilderToolKit, the <a href="#renderengine-BuilderAssembler">Assembler</a> and <a href="#renderengine-ConManager">connection manager</a>. The colaboration of these parts can be seen as the <a href="#renderengine-BuilderMechanics">mechanics of the builder</a>&#8201;&#8212;&#8201;sort of the <em>outward view</em>, contrary to the <em>invard aspects</em> visible when focussing on how the nodes are put together.</p></div>
<div class="imageblock">
<div class="content">
<img src="../uml/fig128517.png" alt="../uml/fig128517.png" />
</div>
</div>
<div class="paragraph"><p><a id="renderengine-BuilderToolKit"></a></p></div>
</div>
<h2 id="_buildertoolkit">BuilderToolKit</h2>
<div class="sectionbody">
<div class="paragraph"><p>Besides the primary working tool within the builder (namely the <a href="#renderengine-PlanningNodeCreatorTool">Node Creator Tool</a>), on a lower level, we encounter several <a href="#renderengine-BuilderPrimitives">elementary building situations</a>&#8201;&#8212;&#8201;and for each of these elementary situations we can retrieve a suitable <em>fitting tool</em> or <a href="#renderengine-BuilderMould">mould</a>. The palette of these moulds is called the <strong>tool kit</strong> of the builder. It is subject to configuration by rules.</p></div>
<h3 id="_addressing_a_mould">addressing a mould</h3><div style="clear:left"></div>
<div class="paragraph"><p>All mould instances are owned and managed by the <a href="#renderengine-BuilderToolFactory">tool factory</a>, and can be referred to by their type (PipeMould, CombiningMould, SourceChainMould, WiringMould) and a concrete object instance (of suitable type). The returned mould (instance) acts as a handle to stick together the given object instance (from the high-level model) with the corresponding point in the low-level node network under construction. As consequence of this approach, the tool factory instance holds a snapshot of the current building state, including all the active spots in the build process. As the latter is driven by objects from the high-level model appearing (in a sensible order  &#8594; see BuilderMechanics) within the NodeCreatorTool, new moulds will be created and fitted as necessary, and existing moulds will be exhausted when finished, until the render node network is complete.</p></div>
<h3 id="_configuring_a_mould">configuring a mould</h3><div style="clear:left"></div>
<div class="paragraph"><p>As each mould kind is different, it has a <tt>prepare(&#8230;)</tt> function with suitably typed parameters. The rest is intended to be  self-configuring (for example, a CombiningMould will detect the actual kind of Transition and select the internal mode of operation), so that it&#8217;s sufficient to just call <tt>operate()</tt></p></div>
<h3 id="_sequence_of_operations">sequence of operations</h3><div style="clear:left"></div>
<div class="paragraph"><p>When <tt>operate()</tt> doesn&#8217;t throw, the result is a list of <em>successor moulds</em>&#8201;&#8212;&#8201;you shouldn&#8217;t use the original mould after triggering its operation, because it may have been retracted as a result and reused for another purpose by the tool factory. It is not necessary to store these resulting moulds either (as they can be retrieved as described above), but they can be used right away for the next building step if applicable. In the state they are returned from a successful building step (mould operation = execution of a contained <a href="#renderengine-ProcPatt">processing pattern</a>), they are usually already holding a reference to the part of the network just created and need to be configured only with the next high-level object (effect, placement, pipe, processing pattern or similar, depending on the concrete situation) in order to carry out the next step.</p></div>
<h3 id="_single_connection_step">single connection step</h3><div style="clear:left"></div>
<div class="paragraph"><p>at the lowest level within the builder there is the step of building a <em>connection.</em> This step is executed by the processing pattern with the help of the mould. Actually, making such a connection is more complicated, because in the standard case it will connect N media streams simultaneously (N=2 for stereo sound or 3D video, N=6 for 5.1 Surround, N=9 for 2nd order Ambisonics). These details are encapsulated within the OperationPoint, which is provided by the mould and exhibits a common interface for the processing pattern to express the connecting operation.</p></div>
<div class="paragraph"><p>&#8594; see also: BuilderPrimitives for the elementary working situations corresponding to each of these <a href="#renderengine-BuilderMould">builder moulds</a></p></div>
<div class="paragraph"><p><a id="renderengine-Command"></a></p></div>
</div>
<h2 id="_command">Command</h2>
<div class="sectionbody">
<div class="paragraph"><p>Within Proc-Layer, a Command is the abstract representation of a single operation or a compound of operations mutating the HighLevelModel.</p></div>
<div class="paragraph"><p>Thus, each command is a <strong>Functor</strong> and a <strong>Closure</strong> (<a href="http://en.wikipedia.org/wiki/Command_pattern">command pattern</a>), allowing commands to be treated uniformly, enqueued in a <a href="#renderengine-ProcDispatcher">dispatcher</a>, logged to the SessionStorage and registered with the UndoManager.</p></div>
<div class="paragraph"><p>Commands are <em>defined</em> using a <a href="http://en.wikipedia.org/wiki/Fluent_interface">fluent API</a>, just by providing apropriate functions. Additionally, the Closure necessary for executing a command is built by binding to a set of concrete parameters. After reaching this point, the state of the internal representation could be serialised by plain-C function calls, which is important for integration with the SessionStorage.</p></div>
<div class="paragraph"><p>&#8594; see CommandDefinition</p></div>
<div class="paragraph"><p>&#8594; see CommandHandling</p></div>
<div class="paragraph"><p>&#8594; see CommandLifecycle</p></div>
<div class="paragraph"><p>&#8594; see CommandUsage</p></div>
<div class="paragraph"><p><a id="renderengine-CommandDefinition"></a></p></div>
</div>
<h2 id="_commanddefinition">CommandDefinition</h2>
<div class="sectionbody">
<div class="paragraph"><p>Commands can be identified and accessed <em>by name</em>&#8201;&#8212;&#8201;consequently there needs to be an internal command registry, including a link to the actual implementing function, thus allowing to re-establish the connection between command and implementing functions when de-serialising a persisted command. To create a command, we need to provide the following informations</p></div>
<div class="ulist"><ul>
<li>
<p>
operation function actually implementing the command
</p>
</li>
<li>
<p>
function to <a href="#renderengine-UndoManager">undo</a> the effect of the command
</p>
</li>
<li>
<p>
function to capture state to be used by UNDO.
</p>
</li>
<li>
<p>
a set of actual parameters to bind into these functions (closure).
</p>
</li>
</ul></div>
<h3 id="_command_definition_object">Command definition object</h3><div style="clear:left"></div>
<div class="paragraph"><p>The process of creating a command by providing these building blocks is governed by a CommandDef helper object. According to the <a href="http://en.wikipedia.org/wiki/Fluent_interface">fluent definition style</a>, the user is expected to invoke a chain of definition functions, finally leading to the internal registration of the completed command object, which then might be dispatched or persisted. For example</p></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight 3.1
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="font-weight: bold"><span style="color: #000000">CommandDefinition</span></span> <span style="color: #990000">(</span><span style="color: #FF0000">"test.command1"</span><span style="color: #990000">)</span>
     <span style="color: #990000">.</span><span style="font-weight: bold"><span style="color: #000000">operation</span></span> <span style="color: #990000">(</span>command1<span style="color: #990000">::</span>operate<span style="color: #990000">)</span>          _ provide the function to be executed as command
     <span style="color: #990000">.</span><span style="font-weight: bold"><span style="color: #000000">captureUndo</span></span> <span style="color: #990000">(</span>command1<span style="color: #990000">::</span>capture<span style="color: #990000">)</span>        _ provide the function capturing Undo state
     <span style="color: #990000">.</span><span style="font-weight: bold"><span style="color: #000000">undoOperation</span></span> <span style="color: #990000">(</span>command1<span style="color: #990000">::</span>undoIt<span style="color: #990000">)</span>       _ provide the function which might undo the command
     <span style="color: #990000">.</span><span style="font-weight: bold"><span style="color: #000000">bind</span></span> <span style="color: #990000">(</span>obj<span style="color: #990000">,</span> val1<span style="color: #990000">,</span>val2<span style="color: #990000">)</span>                  _ bind to the actual <span style="color: #008080">command</span> <span style="font-weight: bold"><span style="color: #000000">parameters</span></span> <span style="color: #990000">(</span>stores <span style="color: #008080">command</span> internally<span style="color: #990000">)</span>
     <span style="color: #990000">.</span><span style="font-weight: bold"><span style="color: #000000">executeSync</span></span><span style="color: #990000">();</span>                         _ <span style="color: #008080">convenience</span> call<span style="color: #990000">,</span> forwarding the Command <span style="color: #008080">to</span> dispatch<span style="color: #990000">.</span></tt></pre></div></div>
<h3 id="_operation_parameters">Operation parameters</h3><div style="clear:left"></div>
<div class="paragraph"><p>While generally there is <em>no limitation</em> on the number and type of parameters, the set of implementing functions and the <tt>bind(&#8230;)</tt> call are required to match. Inconsistencies will be detected by the compiler. In addition to taking the <em>same parameters as the command operation,</em> the <tt>captureUndo()</tt> function is required to return (by value) a <em>memento</em> type, which, in case of invoking the <tt>undo()</tt>-function, will be provided as additional parameter. To summarise:</p></div>
<div class="tableblock">
<table rules="columns"
frame="hsides"
cellspacing="0" cellpadding="4">
<col width="800" />
<thead>
  <tr>
    <th align="left">
    Function
    </th>
  </tr>
</thead>
<tbody valign="top">
  <tr>
    <td align="left">
    operation
    </td>
  </tr>
  <tr>
    <td align="left">
    captureUndo
    </td>
  </tr>
  <tr>
    <td align="left">
    undoOperation
    </td>
  </tr>
  <tr>
    <td align="left">
    bind
    </td>
  </tr>
</tbody>
</table>
</div>
<div class="tableblock">
<table rules="rows"
frame="hsides"
cellspacing="0" cellpadding="4">
<col width="300" />
<col width="500" />
<thead>
  <tr>
    <th align="left">
    Function
    </th>
    <th align="left">
    ret(params)
    </th>
  </tr>
</thead>
<tbody valign="top">
  <tr>
    <td align="left">
    .90.50.100<sub>~</sub>~
    </td>
    <td align="left">
    </td>
  </tr>
  <tr>
    <td align="left">
    operation
    </td>
    <td align="left">
    void
    </td>
  </tr>
  <tr>
    <td align="left">
    captureUndo
    </td>
    <td align="left">
    MEM
    </td>
  </tr>
  <tr>
    <td align="left">
    undoOperation
    </td>
    <td align="left">
    void
    </td>
  </tr>
  <tr>
    <td align="left">
    bind
    </td>
    <td align="left">
    void
    </td>
  </tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Usually, parameters should be passed <em>by value</em>&#8201;&#8212;&#8201;with the exception of target object(s), which are typically bound as MObjectRef, causing them to be resolved at commad execution time (late binding).</p></div>
<div class="paragraph"><p><a id="renderengine-"></a></p></div>
<div class="paragraph"><p><a id="renderengine-"></a></p></div>
<div class="paragraph"><p><a id="renderengine-"></a></p></div>
<div class="paragraph"><p><a id="renderengine-"></a></p></div>
<div class="paragraph"><p><a id="renderengine-DefaultsImplementation"></a></p></div>
</div>
<h2 id="_defaultsimplementation">DefaultsImplementation</h2>
<div class="sectionbody">
<div class="paragraph"><p>As detailed in the <a href="#renderengine-DefaultsManagement">definition</a>, <tt>default(Obj)</tt> is sort of a Joker along the lines <em>give me a suitable Object and I don&#8217;t care for further details</em>. Actually, default objects are implemented by the <tt>mobject::session::DefsManager</tt>, which remembers and keeps track of anything labeled as <em>default</em>. This defaults manager is a singleton and can be accessed via the <a href="#renderengine-Session">Session</a> interface, meaning that the memory track regarding defaults is part of the session state. Accessing an object via the query for an default actually <em>tagges</em> this object (storing a weak ref in the DefsManager). Alongside with each object successfully queried via <em>default</em>, the degree of constriction is remembered, i.e. the number of additional conditions contained in the query. This enables us to search for default objects starting with the most unspecific.</p></div>
<h3 id="_skeleton">Skeleton</h3><div style="clear:left"></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
<strong>search</strong>: using the predicate <tt>default(X)</tt> enumerates existing objects of suitable type
</p>
<div class="ulist"><ul>
<li>
<p>
candidates are delivered starting with the least constrained default
</p>
</li>
<li>
<p>
the argument is unified
</p>
<div class="ulist"><ul>
<li>
<p>
if the rest of the query succeeds we&#8217;ve found our <em>default object</em> and are happy.
</p>
</li>
<li>
<p>
otherwise, if all enumerated solutions are exhausted without success, we enter
</p>
</li>
</ul></div>
</li>
</ul></div>
</li>
<li>
<p>
<strong>default creation</strong>: try to get an object fulfilling the conditions and remember this situation
</p>
<div class="ulist"><ul>
<li>
<p>
we issue an ConfigQuery with the query terms <em>minus</em> the <tt>default(X)</tt> predicate
</p>
</li>
<li>
<p>
it depends on the circumstances how this query is handled. Typically the query resolution first searches existing objects and then creates a new instance to match the required capabilities. Usually, this process succeeds, but there can be configurations leading to failure.
</p>
<div class="ulist"><ul>
<li>
<p>
failing the ConfigQuery is considered an (non-critical) exception (throws), as defaults queries are supposed to succeed
</p>
</li>
<li>
<p>
otherwise, the newly created object is remembered (tagged) as new default, together with the degree of constriction
</p>
</li>
</ul></div>
</li>
</ul></div>
</li>
</ol></div>
<h4 id="_implementation_details">Implementation details</h4>
<div class="paragraph"><p>Taken precisely, the <em>degree of constriction</em> yields only a partial ordering&#8201;&#8212;&#8201;but as the <em>default</em>-predicate is sort of a existential quantification anyways, its sole purpose is to avoid polluting the session with unnecessary default objects, and we don&#8217;t need to care for absolute precision. A suitable approximation is to count the number of predicates terms in the query and use a (sorted) set (separate for each Type) to store weak refs to the the objects tagged as <tt>default</tt>
<tt style="color: red;">WARN</tt> there is an interference with the (planned) Undo function. This is a general problem of the config queries; just ignoring this issue seems reasonable.</p></div>
<h4 id="_problems_with_the_preliminary_mock_implementation">Problems with the (preliminary) mock implementation</h4>
<div class="paragraph"><p>As we don&#8217;t have a Prolog interpreter on board yet, we utilize a mock store with preconfigured answers. (see MockConfigQuery). As this preliminary solution is lacking the ability to create new objects, we need to resort to some trickery here (please look away). The overall logic is quite broken, because the system isn&#8217;t capable to do any real resolution&#8201;&#8212;&#8201;if we ignore this fact, the rest of the algorithm can be implemented, tested and used right now.</p></div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2009-09-17 17:29:02 EDT
</div>
</div>
</body>
</html>
