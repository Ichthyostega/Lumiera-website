== Asset
:Author: Ichthyostega
:Date Created: 200708100337
:Date Changed: 200906071813
:Count Changes: 17
// def classes img

Asset management is a subsystem on its own. Assets are _things_ that can be loaded into a session, like Media, Clips, Effects, Transitions. It is the 'bookkeeping view', while the EDL is the 'manipulation and process view'. Some Assets can be _loaded_ and a collection of Assets is saved with each Session. Besides, there is a collection of basic Assets always available by default.

The Assets are important reference points holding the information needed to access external resources. For example, an Clip asset can reference a Media asset, which in turn holds the external filename from which to get the media stream. For Effects, the situation is similar. Assets thus serve two quite distinct purposes. One is to load, list, group search and browse them, and to provide an entry point to create new or get at existing MObjects in the EDL, while the other purpose is to provide attribute and property informations to the inner parts of the engine, while at the same time isolating and decoupling them from environmental details.

We can distinguish several different Kinds of Assets, each one with specific properties. While all these Kinds of Assets implement the basic Asset interface, they in turn are the 'key abstractions' of the asset management view. Mostly, their interfaces will be used directly, because they are quite different in behaviour. Thus it is common to see asset related operations being templated on the Asset Kind.

-> see also <<renderengine-AssetCreation, Creating and registering Assets>>

image::../uml/fig130309.png[Asset Classes]

=== Media Asset
Some piece of Media Data accessible at some external Location and able to be processed by Lumiera. A Media File on Harddisk can be considered as the most basic form of Media Asset, with some important derived flavours, like a Placeholder for a currently unavailable Source, or Media available in different Resolutions or Formats.

* 'outward interface operations' include querying properties, creating an Clip MObject, controlling processing policy (low res proxy placeholders, interlacing and other generic pre- and postprocessing)
* 'inward interface operations' include querying filename, codec, offset and any other informations necessary for creating a source render node, getting additional processing policy decisions (handling of interlacing, aspect ratio).

-> MediaAsset

=== Processing Asset
Some software component able to work on media data in the Lumiera Render engine Framework. This includes all sorts of loadable effects, as well as some of the standard, internal facilities (Mask, Projector). Note that Processing Assets typically provide some attachment Point or means of communication with GUI facilities.

* 'outward interface operations' include getting name and description, investigating the media types the processor is able to handle, cause the underlying module to be acutally loaded...
* 'inward interface operations' include resolving the actual processing function.

-> ProcAsset

=== Structural Asset
Some of the building blocks providing the framework for the objects placed into the current Session. Notable examples are <<renderengine-Pipe,processing pipes>> within the high-level-model, Viewer attachment points, Tracks, etc.

* 'outward interface operations' include...
* 'inward interface operations' include...

-> StructAsset [red]+to be defined+

=== Meta Asset
Some additional, virtual facilities created in the course of the editing process. Examples are Automation data sets, Labels and reference points, Meta Clips (nested sub-EDLs)

* 'outward interface operations' include...
* 'inward interface operations' include...

-> MetaAsset [red]+to be defined+

==== still to be worked out..
is how to implement the relationship between <<renderengine-MObject, MObject>>s and Assets. Do we use direct pointers, or do we prefer an ID + central registry approach? And how to handle the removal of an Asset.

-> see also <<renderengine-ManagementAssetRelation, analysis of mem management>>

-> see also <<renderengine-ObjectCreation, Creating Objects>>, especially <<renderengine-AssetCreation, Assets>>

_9/07: currently implementing it as follows: use a refcounting-ptr from Clip-MObject to asset::Media while maintaining a dependency network between Asset objects. We'll see if this approach is viable_

