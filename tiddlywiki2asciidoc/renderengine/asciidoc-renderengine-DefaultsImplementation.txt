== DefaultsImplementation
:Author: Ichthyostega
:Date Created: 200802200043
:Date Changed: 200806030204
:Count Changes: 12
// spec impl draft

As detailed in the <<renderengine-DefaultsManagement,definition>>, +default(Obj)+ is sort of a Joker along the lines 'give me a suitable Object and I don't care for further details'. Actually, default objects are implemented by the +mobject::session::DefsManager+, which remembers and keeps track of anything labeled as 'default'. This defaults manager is a singleton and can be accessed via the <<renderengine-Session,Session>> interface, meaning that the memory track regarding defaults is part of the session state. Accessing an object via the query for an default actually _tagges_ this object (storing a weak ref in the DefsManager). Alongside with each object successfully queried via 'default', the degree of constriction is remembered, i.e. the number of additional conditions contained in the query. This enables us to search for default objects starting with the most unspecific.

=== Skeleton
. *search*: using the predicate +default(X)+ enumerates existing objects of suitable type
* candidates are delivered starting with the least constrained default
* the argument is unified
 - if the rest of the query succeeds we've found our _default object_ and are happy.
 - otherwise, if all enumerated solutions are exhausted without success, we enter
. *default creation*: try to get an object fulfilling the conditions and remember this situation
* we issue an ConfigQuery with the query terms _minus_ the +default(X)+ predicate
* it depends on the circumstances how this query is handled. Typically the query resolution first searches existing objects and then creates a new instance to match the required capabilities. Usually, this process succeeds, but there can be configurations leading to failure.
 - failing the ConfigQuery is considered an (non-critical) exception (throws), as defaults queries are supposed to succeed
 - otherwise, the newly created object is remembered (tagged) as new default, together with the degree of constriction

==== Implementation details
Taken precisely, the 'degree of constriction' yields only a partial ordering -- but as the 'default'-predicate is sort of a existential quantification anyways, its sole purpose is to avoid polluting the session with unnecessary default objects, and we don't need to care for absolute precision. A suitable approximation is to count the number of predicates terms in the query and use a (sorted) set (separate for each Type) to store weak refs to the the objects tagged as +default+
[red]+WARN+ there is an interference with the (planned) Undo function. This is a general problem of the config queries; just ignoring this issue seems reasonable.

==== Problems with the (preliminary) mock implementation
As we don't have a Prolog interpreter on board yet, we utilize a mock store with preconfigured answers. (see MockConfigQuery). As this preliminary solution is lacking the ability to create new objects, we need to resort to some trickery here (please look away). The overall logic is quite broken, because the system isn't capable to do any real resolution -- if we ignore this fact, the rest of the algorithm can be implemented, tested and used right now.