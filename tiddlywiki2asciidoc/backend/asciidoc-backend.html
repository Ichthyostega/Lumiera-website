<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.4.5" />
<title></title>
<style type="text/css">
/* Debug borders */
p, li, dt, dd, div, pre, h1, h2, h3, h4, h5, h6 {
/*
  border: 1px solid red;
*/
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

tt {
  color: navy;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  font-family: sans-serif;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}

div.sectionbody {
  font-family: serif;
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}

pre {
  padding: 0;
  margin: 0;
}

span#author {
  color: #527bbd;
  font-family: sans-serif;
  font-weight: bold;
  font-size: 1.1em;
}
span#email {
}
span#revnumber, span#revdate, span#revremark {
  font-family: sans-serif;
}

div#footer {
  font-family: sans-serif;
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
div#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
div#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

div#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.tableblock, div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.5em;
  margin-bottom: 2.5em;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-family: sans-serif;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid silver;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid silver;
  background: #f4f4f4;
  padding: 0.5em;
}

div.quoteblock {
  padding-left: 2.0em;
  margin-right: 10%;
}
div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock {
  padding-left: 2.0em;
  margin-right: 10%;
}
div.verseblock > div.content {
  white-space: pre;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 2px solid silver;
}

div.exampleblock > div.content {
  border-left: 2px solid silver;
  padding: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

div.tableblock > table {
  border: 3px solid #527bbd;
}
thead {
  font-family: sans-serif;
  font-weight: bold;
}
tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

@media print {
  div#footer-badges { display: none; }
}

div#toctitle {
  color: #527bbd;
  font-family: sans-serif;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}
/* Workarounds for IE6's broken and incomplete CSS2. */

div.sidebar-content {
  background: #ffffee;
  border: 1px solid silver;
  padding: 0.5em;
}
div.sidebar-title, div.image-title {
  color: #527bbd;
  font-family: sans-serif;
  font-weight: bold;
  margin-top: 0.0em;
  margin-bottom: 0.5em;
}

div.listingblock div.content {
  border: 1px solid silver;
  background: #f4f4f4;
  padding: 0.5em;
}

div.quoteblock-attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock-content {
  white-space: pre;
}
div.verseblock-attribution {
  padding-top: 0.75em;
  text-align: left;
}

div.exampleblock-content {
  border-left: 2px solid silver;
  padding-left: 0.5em;
}

/* IE6 sets dynamically generated links as visited. */
div#toc a:visited { color: blue; }
</style>
</head>
<body>
<div id="header">
</div>
<div class="paragraph"><p><a id="backend-initial"></a></p></div>
<h2 id="_data_backend">Data Backend</h2>
<div class="sectionbody">
<div class="ulist"><div class="title">This just starts as braindump, I will refine it soon</div><ul>
<li>
<p>
handle all files Lumiera uses at runtime (media, edl, temp data)
</p>
</li>
<li>
<p>
manage filehandles, Lumiera might use more more files than available filehandles
</p>
</li>
<li>
<p>
manage temporary data
</p>
</li>
<li>
<p>
do caching
</p>
</li>
<li>
<p>
io will be blocked where the backend tells the core where it can expect the data (not read()/write() like)
</p>
</li>
<li>
<p>
kind-of garbage collector
</p>
</li>
<li>
<p>
do prefetching
</p>
</li>
<li>
<p>
no/low latency for the core the prefetcher and other things ensure that data is available in time
</p>
</li>
<li>
<p>
translate any input into a format which the Lumiera core understands (demux, decode)
</p>
</li>
<li>
<p>
same for encoding to output formats
</p>
</li>
<li>
<p>
offer a plugin API for encoders/decoders
</p>
</li>
<li>
<p>
maybe network backend for serving data to distributed render nodes
</p>
</li>
<li>
<p>
can do some load control or management (trigger adaptive rendering if system is idle etc)
</p>
</li>
<li>
<p>
pull based arch
</p>
</li>
<li>
<p>
Serialize persistent data (Project / EDL&#8217;s)
</p>
</li>
</ul></div>
<div class="paragraph"><p>Look at <a href="#backend-overview">overview</a> for the current design proposal</p></div>
<div class="paragraph"><p><a id="backend-File"></a></p></div>
</div>
<h2 id="_file">File</h2>
<div class="sectionbody">
<div class="paragraph"><p><tt>File</tt> associates a filename with the underlying <a href="#backend-FileDescriptor"><tt>FileDescriptor</tt></a>. This allows <tt>File</tt>s which have serveral names (<tt>hardlinks</tt>) to share a underlying backend.</p></div>
<div class="paragraph"><p><a id="backend-FileDescriptor"></a></p></div>
</div>
<h2 id="_filedescriptor">FileDescriptor</h2>
<div class="sectionbody">
<div class="paragraph"><p><tt>FileDescriptor</tt> is the superclass of all possible filetypes, it has a weak reference to a <a href="#backend-FileHandle"><tt>FileHandle</tt></a> which is managed in <a href="#backend-FilehandleCache"><tt>FilehandleCache</tt></a>, on creation only the existence (when reading) or access for write for new files are checked. <tt>FileDescriptor</tt> stores some generic metadata about the underlying file and intended use. But actual opening is done on demand.</p></div>
<div class="paragraph"><p>The content is memory mapped into the process address space, this is managed by <a href="#backend-FileMap"><tt>FileMap</tt></a> objects and a <a href="#backend-FileMapCache"><tt>FileMapCache</tt></a>.</p></div>
<div class="paragraph"><p><a id="backend-FileHandle"></a></p></div>
</div>
<h2 id="_filehandle">FileHandle</h2>
<div class="sectionbody">
<div class="paragraph"><p><tt>FileHandle</tt>s are managed by the <a href="#backend-FilehandleCache"><tt>FilehandleCache</tt></a>, they are just storing the underlying OS file handles and managed in a lazy/weak way, (re)opened when needed and aging in the cache when not needed, since the amount of open file handles is limited aged ones will be closed and reused when the system needs to open another file.</p></div>
<div class="paragraph"><p><a id="backend-FilehandleCache"></a></p></div>
</div>
<h2 id="_filehandlecache">FilehandleCache</h2>
<div class="sectionbody">
<div class="paragraph"><p><tt>FilehandleCache</tt> storing a finite maximum number of <a href="#backend-FileHandle"><tt>FileHandle</tt></a>s as a list. As long the configured maximum of open files is not reached new file handles are stored at the begin of the list. Whenever a <tt>filehandle</tt> is accessed it is moved to the begin of the list too. Unused filehandles propagate towards the end of the list. When the maximum of open <tt>filehandle</tt>s is reached, aged filehandles are closed and taken from the end.</p></div>
<div class="paragraph"><p><a id="backend-FileMap"></a></p></div>
</div>
<h2 id="_filemap">FileMap</h2>
<div class="sectionbody">
<div class="paragraph"><p>Each <tt>FileMap</tt> object contains many <a href="#backend-Frame"><tt>Frame</tt></a>s. The actual layout depends on the type of the <a href="#backend-File"><tt>File</tt></a>. Mappings need to be page aligned while <tt>Frame</tt>s can be anywhere within a file and dynamically sized.</p></div>
<div class="paragraph"><p>All established <tt>FileMap</tt>s are managed in a <a href="#backend-FileMapCache"><tt>FileMapCache</tt></a>. This is similar to the <a href="#backend-FilehandleCache"><tt>FilehandleCache</tt></a>, but mappings which are in use are checked out of the aging list and thus become locked from aging/purging.</p></div>
<div class="paragraph"><p><tt>FileMap</tt> objects are transparent to the application. It will only requests <tt>Frame</tt>s as in position and size (and some other parameters).</p></div>
<div class="paragraph"><p><a id="backend-FileMapCache"></a></p></div>
</div>
<h2 id="_filemapcache">FileMapCache</h2>
<div class="sectionbody">
<div class="paragraph"><p>The <tt>FileMapCache</tt> keeps a list of <a href="#backend-FileMap"><tt>FileMap</tt></a>s which are currently not in use and subject of aging.  Whenever a <tt>FileMap</tt> is in use, it is checked out into an in-use list where it is not subject to aging.</p></div>
<div class="paragraph"><p><a id="backend-Frame"></a></p></div>
</div>
<h2 id="_frame">Frame</h2>
<div class="sectionbody">
<div class="paragraph"><p><tt>Frames</tt> are the smallest datablocks handled by the Backend. The application tells the <tt>Backend</tt> to make <a href="#backend-File"><tt>File</tt></a>s available and then only requests Frames from the Backend. All other datastructures of the backend are private.</p></div>
<div class="paragraph"><p>Actually Frames are (references to) blocks of continuous memory. They can be anything depending on the usage of the <tt>File</tt> (Video frames, encoder frames, blocks of sound samples).</p></div>
<div class="paragraph"><p>Each <tt>Frame</tt> points to a <a href="#backend-FrameDescriptor"><tt>FrameDescriptor</tt></a> which describes the shared properties of <tt>Frame</tt>s of the same kind. For video frames this <tt>FrameDescriptor</tt> will define the policies of the used color model, resolution, aspect ratio and so on, for example.</p></div>
<div class="paragraph"><p>Frames are referenced by a smart-pointer like object which manages the lifetime and caching behavior. There are 3 states such a frame reference can be in:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
readonly: the backing <a href="#backend-FileMap"><tt>FileMap</tt></a> is checked out from the aging list, frames can be read
</p>
</li>
<li>
<p>
readwrite: the backing <tt>FileMap</tt> is checked out from the aging list, frames can be read and written (depends on the filemode as well)
</p>
</li>
<li>
<p>
weak: the <tt>FileMap</tt> object is checked back into the aging list, the frame can&#8217;t be accessed but we can try to transform a weak reference into a readonly or readwrite reference
</p>
</li>
</ol></div>
<div class="paragraph"><p>Frames can be addressed uniquely (needs to be worked out) whenever a frame is not available. The backend can initiate a (probably recursive) render for it.</p></div>
<div class="paragraph"><p>Accessing <tt>Frame</tt>s may add further renderjobs for related frames to the <a href="#backend-Prefetch"><tt>Prefetch</tt></a> task.</p></div>
<div class="paragraph"><p><a id="backend-Notes"></a></p></div>
</div>
<h2 id="_notes">Notes</h2>
<div class="sectionbody">
<div class="paragraph"><p>How is <tt>FileMetadata</tt> kept</p></div>
<div class="paragraph"><p>copying semantics of smart pointers</p></div>
<div class="paragraph"><p>explain opening/closing files (use() forget()?)</p></div>
<div class="paragraph"><p>difference between actual files and temporary. does it make sense to have temporary storage on diffent speed disks?</p></div>
<div class="paragraph"><p>statistics hit/fail max/min/avg timings, hard / soft fails, timing constraints, when is rerendering cheaper than caching?..</p></div>
<div class="paragraph"><p>adaptive rendering</p></div>
<div class="paragraph"><p>background rendering</p></div>
<div class="paragraph"><p>renderfarm</p></div>
<div class="paragraph"><p><tt>FrameDescriptor</tt>s and <a href="#backend-Frame"><tt>Frame</tt></a> details, Policies composing frames</p></div>
<div class="paragraph"><p>Storage and logging of EDL&#8217;s, unlimited undo, database,&#8230;</p></div>
<div class="paragraph"><p>When to Cache and when not to cache, aka instant <tt>Frame</tt> reuse</p></div>
<div class="paragraph"><p><a id="backend-overview"></a></p></div>
</div>
<h2 id="_overview">Overview</h2>
<div class="sectionbody">
<div class="paragraph"><p>Whenever Lumiera needs to access data this is done through the <tt>DataBackend</tt> described here.</p></div>
<div class="paragraph"><p>There are two main kinds how data is handled:</p></div>
<div class="ulist"><ul>
<li>
<p>
Project Description and EDL&#8217;s are handled in a <tt>InMemoryDatabase</tt> which uses a <tt>Serializer</tt> for storing and logging modifications.
</p>
</li>
<li>
<p>
Media (audio, video, &#8230;) is mapped as described below.
</p>
</li>
</ul></div>
<div class="paragraph"><p>The backend uses memory mapping to make data available to the program. This is little different to more common open/read/write/close file access while giving superior performance and much better memory utilization.</p></div>
<div class="paragraph"><p>The data backend must be capable to handle more data than will fit into the memory or even address space on 32 bit architectures.  Moreover a project may access more files than the OS can handle at a time, thus the for <tt>File</tt>s used by the <tt>Backend</tt> it needs a <a href="#backend-FilehandleCache"><tt>FilehandleCache</tt></a> to manage <a href="#backend-FileHandle"><tt>FileHandle</tt></a>s dynamically.</p></div>
<div class="paragraph"><p>Which parts of a <tt>File</tt> are actually mapped to physical RAM is managed by the kernel, it keeps a <a href="#backend-FileMapCache"><tt>FileMapCache</tt></a> to manage the <a href="#backend-FileMap"><tt>FileMap</tt></a>s we&#8217;ve set up.</p></div>
<div class="paragraph"><p>The application itself only requests <a href="#backend-Frame"><tt>Frame</tt></a>s from the Backend.</p></div>
<div class="paragraph"><p>To minimize latency and optimize CPU utilization we have a <a href="#backend-Prefetch"><tt>Prefetch</tt></a> thread which operates a <a href="#backend-Scheduler"><tt>Scheduler</tt></a> to render and cache frames which are expected to be consumed soon. This prefetcher keeps <tt>Statistics</tt> for optimizing performance.</p></div>
<div class="paragraph"><p><a id="backend-Prefetch"></a></p></div>
</div>
<h2 id="_prefetch">Prefetch</h2>
<div class="sectionbody">
<div class="paragraph"><p>There are 2 important points when we want to access data with low latency:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Since we handle much more data than it will fit into most computers RAM. The data which is backed in files has to be paged in and available when needed. The <tt>Prefetch</tt> Thread manages page hinting to the kernel (posix_madvise()..)
</p>
</li>
<li>
<p>
Intermediate <a href="#backend-Frame"><tt>Frame</tt></a>s must eventually be rendered to the cache. The <tt>Backend</tt> will send <tt>Renderjobs</tt> to the <tt>Controller</tt>.
</p>
</li>
</ol></div>
<div class="paragraph"><p>Both of these actions are managed by a <a href="#backend-Scheduler"><tt>Scheduler</tt></a>.</p></div>
<div class="paragraph"><p>Whenever something queries a <tt>Frame</tt> from the backend it provides hints about what it is doing.
These hints contain:</p></div>
<div class="ulist"><ul>
<li>
<p>
Timing constraints
</p>
<div class="ulist"><ul>
<li>
<p>
When will the <tt>Frame</tt> be needed
</p>
</li>
<li>
<p>
could we drop the request if it won&#8217;t be available (rendered) in-time
</p>
</li>
</ul></div>
</li>
<li>
<p>
Priority of this job (as soon as possible, or just in time?)
</p>
</li>
<li>
<p>
action (Playing forward, playing backward, tweaking, playback speed, recursive rendering of dependent frames)
</p>
</li>
</ul></div>
<div class="ulist"><div class="title">Notes</div><ul>
<li>
<p>
The Backend will try to render related frames in groups.
</p>
<div class="ulist"><ul>
<li>
<p>
This means that following frames are scheduled with lower priority. Whenever the program really requests them the priority will be adjusted.
</p>
</li>
</ul></div>
</li>
</ul></div>
<div class="paragraph"><p><a id="backend-Scheduler"></a></p></div>
</div>
<h2 id="_scheduler">Scheduler</h2>
<div class="sectionbody">
<div class="paragraph"><p>Scheduling is done with two priority queues, one for high priority jobs and one for low priority jobs. These priority queues are ordered by absolute time values (and a job identifier, details will be worked out at implementation time).</p></div>
<div class="paragraph"><p>There are following (non exhaustive) kinds of jobs:</p></div>
<div class="ulist"><ul>
<li>
<p>
start job
</p>
</li>
<li>
<p>
cancel job, if not finished (abort when out of time)
</p>
</li>
<li>
<p>
unschedule job
</p>
</li>
</ul></div>
<div class="paragraph"><p>Jobs implement a kind of future, datastructures which block a querier until data is available.</p></div>
<div class="paragraph"><p>The Job scheduler runs singlethreaded. Its only task is to schedule and delegate jobs to worker threads, by itself it will never do any extensive processing!</p></div>
<div class="paragraph"><p>Each job has an option what to do when its times expires (abort, proceed).</p></div>
<div class="paragraph"><p>The high priority queue is ordered by the <em>start</em> time T, when the job has to be started (plus some hystersis H). A high priority job becomes scheduled beginning with time T but no later than T+H.</p></div>
<div class="paragraph"><p>The low priority queue is ordered by <em>end</em> time T, when the job has to be finished (minus a spawn S). Low priority jobs are started as soon as system load permits, the high priority queue is empty (for some usec in future, lets say 100) and the time is earlier than ~T-S. When a job is expired, it is removed from the queue, when it is already running it is handled as defined in its expire policy.</p></div>
<div class="paragraph"><p>Canceling and expireing jobs gets noted in <tt>Statistics</tt> to adjust performance and timings for optimal performance.</p></div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2009-09-15 18:10:30 EDT
</div>
</div>
</body>
</html>
