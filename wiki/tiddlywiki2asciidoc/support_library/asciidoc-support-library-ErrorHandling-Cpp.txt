== ErrorHandling-Cpp
:Author: Ichthyostega
:Date Created: 200708140640
:Date Changed: 200708290301
:Count Changes: 3

Basically, the C++ error handling techniques are layered on top of the <<support-library-ErrorHandling-C, C solution>>.

=== Proposal:
We use a common base class for all our application specific exceptions. These exceptions can be thought of as a classification of error situations, thus the hierarchical approach. The purpose of throwing such a _classified exception_ is

* to do a controlled partial failure
* to trigger automatic cleanup without the need to implement the details

==== Requirements for the Exception Interface
* a means for capturing and transporting detail informations
* the possibility to get at the *root cause* of an exception, even after having passed several subsystem barriers.
* getting standardized error messages automatically

==== provided features
The C++ errorhandling Classes and functions can be found in +common/error.hpp+ (not to be confused with the elementary C errorhandling of the Lumiera support lib +lib/error.h+. See also the "exceptionerrortest.cpp"

* the constructor of the Exception base class will set the C-style error flag as well. Obviously, when an exception gets caught and handled, this error-flag should be reset (and this is the responsibility of the handler).
* we add a +unknown()+ handler which will print additional diagnostics.
* the Exception class has a diagnostic message intended for developers and a friendly message for the user. It is encouraged to write a detailed description of each error situation right into a string constant passed to the exception object ctor. This will serve the purpose of documenting the error situation in the source code and at the same time help diagnosis.
* there is a variant of the constructor taking a reference to an std::exception. This is intended for _chained exceptions_. Whenever an handler catches an exception, but then decides to rethrow it with different classification, the original exception object should be passed on by using this constructor, so it's +what()+ message can be preserved and will be included in the final log entry. While this may look like overkill in a small example, it is a very helpful facility in a larger layered application, where it is often difficult to spot the original cause of an exception encountered.
* for each mayor category of Exception subclasses, we define a C-style error constant. The client code is free to define further detailed error constants and Exception subclasses.
* to help defining Exception subclasses, a macro +LUMIERA_EXCEPTION_DECLARE+ is provided.

.basic Exception categories
[grid="rows"]
`90`300~~~~
category,description
~~~~
error::Logic,contradiction to internal logic assumptions detected
error::Fatal,"special subclass of Logic: situation can't be handled, internal logic floundered"
error::Config,execution aborted due to misconfiguration
error::State,unforeseen internal state
error::Invalid,invalid input or parameters encountered
error::External,failure in external service the application relies on
~~~~
