Lumiera 2019 Development Report
===============================
:Date: Autumn 2019
:Author: Benny Lyons & Hermann Voßeler
:toc:

//Menu: label 19-09 Dev Report


.Introduction
We review the status of the project here.  Traditionally, we present _our_
view of the project.  However, from another perspective, some statistics about
Lumiera from another source, https://www.openhub.net/p/lumiera/[Openhub]
might be interesting:

 - 115,094 lines of code; 88% written in C++
 - Using the https://en.wikipedia.org/wiki/COCOMO#History[Basic COCOMO Model],
   this translates into a programming effort of about 30 years; in a commertial
   setup such effort would relate to a code base value of ~$1.6 million.
 - Very well-commented source code, placing ``Lumiera among the top 10% of all
   C++ projects on Open Hub''.
 - Rated with five stars by 4 people. Two people even clicked ``I use this'' +
   _Who did this?_ confess! ;-)
 - 31% less activity in 2019

So why then less activity over the previous year?  _Ichthyo_ devoted a number of
months pursuing other activities, most notably some music composition projects
and his contribution to the
http://yoshimi.sourceforge.net/[Yoshimi soft synthesiser], which emerged after his
https://media.ccc.de/v/lac2018-12-inbuilt_musicality[Workshop »Inbuilt Musicality« at LAC 2018 Berlin].


Project Activity
----------------

Appropriate Nomenclature
~~~~~~~~~~~~~~~~~~~~~~~~
``What's in a name?'' Juliet says to Romeo in the famous balcony scene by
Shakespeare. Indeed Robert Cecil Martin (aka Uncle Bob) has considerably
more to say about the importance of selecting words to name things in our code.
Modern practice of programming has embraced these ideas and the
importance of this is now widespread.

We've spent considerable time in selecting appropriate vocabulary throughout the
project and we were increasingly unhappy with two terms: ``proc'' and ``backend'',
which over time became misaligned with the actual purpose of these layers. So
we've link:{rfc}/LayerNames.html[decided to rename] these.
The ``proc layer'' is now known as the _steam layer_, and the
``backend'' has been renamed to be the _vault layer_. While the former
`namespace gui` became _the stage._


The Timeline View
~~~~~~~~~~~~~~~~~
The Timeline View has received some developer attention.

Recall that the Timeline is a time axis with one or more outputs. Each
output can have its own configuration. A Sequence can then be attached to the
timeline, and within each Sequence, clips are placed and arranged onto a fork
of tracks.

The timeline obviously features on the stage and is without a hard wired
structure. Fixing the layout of the Timeline would not be a good idea as the
structure of the Timeline is personal and a matter of individual taste. The layout
tends to follow the way the editor presers to arrange material. The _session
model_ down in the steam layer is very flexible in this respect. We thus find
ourselves in a dilemma: how can we transfer the current structure onto the stage
without the evil of creating tight coupling between the session and the
internals of the of the stage? The solution, however it might turn out
to be, will be time consuming and complex. Moreover time must be invested in how
this might be done at an early stage of the project. The penalities resulting in
tackling this problem later in the project are simply too high.

Currently, we are able to trigger a (dummy) structure message from the steam layer,
which is translated into an corresponding arrangement of timeline and track widgets
on the stage.


Custom drawing and CSS
~~~~~~~~~~~~~~~~~~~~~~
Building a user interface for media applications often pushes the underlying toolkit
to its limits. While a typical modern UI toolkit tends to be fairly complete and well
fitted for your typical ``business application'', the challenges of media handling
necessitate building some select widgets from scratch. This, in turn, gives rise to a
specific twist, since contemporary users also expect more beyond just some functional
drop-down boxes to click at. A lot of design slickness has been added to most UI toolkits,
and this endangers our custom made widgets to get into the way in various respects, be
it just visually, or in terms of ergonomy.

Instead of just drawing some boxes with Cairo, a lot of effort has been put into assembling
as much as possible from existing code and layout building blocks already present in GTK.
Most notably, we have developed a way for our custom drawing code to pick up theming and
styling from the user's CSS stylesheet, and we provide the necessary extension hooks
to allow users to style even our custom made arrangement of components to their heart's
desire. Lumiera will ship with a dedicated _Application Style Sheet_ in the
subdued gray look typical for of professional media work applications.footnote:[
In fact, the actual graphics work for this Application Style Sheet still needs to be
completed. We'll build upon the stylesheet our former GUI developer, _Joel Holdsworth_
extracted from the https://Ardour.org[Addour DAW] years ago.] Alternatively, we also
provide a light theme / dark theme ``complement stylesheet'' to fill in just that
bare minimum of additional layout and styling required to run Lumiera on top of
the typical desktop light or dark themes.


Status of Support for C++17
~~~~~~~~~~~~~~~~~~~~~~~~~~~
We always strive to support the latest software versions.
We currently adhere to the C\+\+14 language standard. Out next objective is to compile
with C\+\+17. We expect not much impact from this upgrade in language standards, which
can be applied once we raise our ``reference platform'' from Debian/Stretch to the
recently released Debian/Buster. Beyond that, we're already looking ahead at the
upcoming C++20 language standard. Lumiera will certainly benefit from the
Range TS and the introduction of Concepts, which fits in well with the way we are
using templates in the code base to create and assemble generic building blocks.
