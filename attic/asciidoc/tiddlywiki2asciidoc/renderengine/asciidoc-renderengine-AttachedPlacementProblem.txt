== AttachedPlacementProblem
:Author: Ichthyostega
:Date Created: 200801111305
:Date Changed: 200905310342
:Count Changes: 17
// SessionLogic impl draft dynamic

Placing an MObject relatively to another object such that it should be handled as _attached_ to the latter results in several design and implementation challenges. Actually, such an attachment creates a cluster of objects. The typical use case is that of an effect attached to a clip or processing pipe.

* attachment is not a globally fixed relation between objects, rather, it typically exists only for some limited time span (e.g. the duration of the basic clip the effect is attached to)
* the order of attachment is important and the attached placement may create a fork in the signal flow, so we need a way for specifying reproducibly how the resulting wiring should be
* when building, we access the information in reversed direction: we have the target object and need to query for all attachments

The first step towards an solution is to isolate the problem; obviously we don't need to store the objects differently, we just need _information about attached objects_ for some quite isolated tasks (namely for creating a GUI representation and for combining attached objects into a <<renderengine-Pipe,Pipe>> when building). Resorting to a query (function call) interface should turn the rest of the problem into an implementation detail. Thus:

* for an 'attachment head' (= +Placement<MObject>+ to which other objects have been attached) get the ordered list of attachments
* for an 'attached placement' (member of the cluster) get the placement of the corresponding attachment head
* retrieve and break the attachment when _deleting._

=== Implementation notes
Attachment is managed within the participating placements, mostly by special <<renderengine-LocatingPin,locating pins>>. Attachment doesn't necessarily nail down an attached object to a specific position, rather the behaviour depends on the type of the object and the locating pins actually involved, especially on their order and priority. For example, if an +Placement<Effect>+ doesn't contain any locating pin defining a temporal position, then the attachment will result in the placement inheriting the temporal placement of the _attachment head_ (i.e. the clip this effect has been attached to). But, if on the contrary the effect in question _does_ have an additional locating pin, for example relative to another object or even to a fixed time position, this one will 'win' and determine the start position of the effect -- it may even move the effect out of the time interval covered by the clip, in which case the attachment has no effect on the clip's processing pipe.

The attachment relation is hierarchical and has a clearly defined _active_ and _passive_ side: The attachment head is the parent node in a tree, but plays the role of the passive partner, to which the child nodes attach. But note, this does not mean we are limited to a single attachment head. Actually, each placement has a list of locating pins and thus can attach to several other placements. For example, a transition attaches to at least two local pipes (clips). [red]+TODO: unresolved design problem; seems to contradict the PlacementScope+

==== Relation to memory management
Attachment on itself does _not_ keep an object alive. Rather, it's implemented by an opaque ID entry ( -> PlacementRef), which can be resolved by the PlacementIndex. The existence of attachments should be taken into account when deleting an object, preferably removing any dangling attachments to prevent an exception to be thrown later on. On the other hand, contrary to the elements of the HighLevelModel, processing nodes in the render engine never depend on placements -- they always refer directly to the MObject instance or even the underlying asset. In the case of MObject instances, the pointer from within the engine will _share ownership_ with the placement (remember: both are derived from +boost::shared_ptr+).