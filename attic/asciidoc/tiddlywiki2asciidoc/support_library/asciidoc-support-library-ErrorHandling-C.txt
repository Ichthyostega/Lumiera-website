== ErrorHandling-C
:Author: Ichthyostega
:Date Created: 200707152252
:Date Changed: 200708140628
:Count Changes: 1
// excludeMissing

=== Proposal:
We need some centralized way to handle errors and doing hard aborts.

I started using C-string addresses as errors for now. I think that is convenient and unique enough until we find something better. (Actually, this might be even kept in a library. Alternatively, maybe someone wants to investigate libcomerr)

Notes about libcomerr (I took a short look now):

* needs some central error description table which has to be compiled with compile_et
* no homepage found, some projects use it, published in 1989, dunno about its state

My following proposal defines a very simplistic way to define unique errors which can distributed throughout the application (each part can define its own errors and will never interfere with others)

==== detailed semantics (proposal):
a TLS pointer is allocated to keep a thread local error state. NULL means SUCCESS, no error pending.

API:

[source,c]
----
const char*
lumiera_error_set (const char * err)
----

if there is no error pending, then store err as new error state, if there was an error pending, then the state is not altered.

return the former state (NULL if err got set, some other when an error is pending)

[source,c]
----
const char*
lumiera_error ()
----

returns the error state *and* clears it. The user has to store it temporary when need to be used further. Rationale: less TLS access overhead, never forget to clear the state.

(do we need a +lumiera_error_peek()+?)

Declaration and definition:

[source,c]
----
#define LUMIERA_ERROR_DECLARE(err) \
extern const char* LUMIERA_ERROR_##err

#define LUMIERA_ERROR_DEFINE(err, msg) \
const char* LUMIERA_ERROR_##err = "LUMIERA_ERROR_" #err ":" msg
----

thus a +LUMIERA_ERROR_DEFINE(NFOO, "Foo not found")+ will result in a string:
"LUMIERA_ERROR_NFOO:Foo not found", having the identifier itself prepended to the string will ensure uniqueness of the generated literal (and thus its pointer value), reducing error testing to address comparison +lumiera_error()==LUMIERA_ERROR_NFOO+. The message string is easily derived by +strchr(LUMIERA_ERROR_NFOO, ":")+1+

==== Allocation
The next point is allocation failures. These are possible by C/C++ standard but don't actually happen anymore in Linux (except in few rare cases). Instead of gracefully handling this errors I'll add a +LUMIERA_DIE(message)+ macro to this library later. This macro will just do (NoBug) logging and then doing a hard abort. It should be a macro because we want to preserve file/line location for logging.
